{
  "name": "Jsloader",
  "tagline": "1.0.0",
  "body": "# Welcome to JSLoader\r\n\r\nThe JSLoader is basicly a little js-architecture to structure your application a bit better, have all your dependencies clear and making multifile-usage in JavaScript a lesser pain in the ass.\r\n\r\nAdvantages:\r\n - Abstract Code\r\n - All dependencies in 1 file\r\n - Easy usage\r\n - No jQuery required\r\n\r\n## Structure\r\n* scripts/\r\n  * app/\r\n    * extensions/\r\n      * lib/\r\n    * appMain.js\r\n    * config.js\r\n  * lib/\r\n    * extensionLoader.js\r\n    * require.js\r\n  * main.js\r\n\r\n### scripts/lib\r\nHere are all third-party js-libraries.\r\n\r\n### scripts/app/extensions\r\nYou store your executables here.\r\n\r\n### scripts/app/extensions/lib\r\nYou store your own libraries here.\r\n\r\n### main.js\r\nHere is the requireJS Configuration. It's already preconfigured for the basic functionality.  \r\nJust fit the baseUrl to your needs. That's it.\r\n\r\n### appMain.js\r\nThis file is the first file loaded after the main.js.\r\nHere goes the code you always need.\r\n\r\n### config.js\r\nYou configure your extensions here.\r\n\r\n```javascript\r\ndefine([\"ExtensionLoader\"], function() {\r\n    var loader = ExtensionLoader();\r\n  \r\n    loader.addConfig({\r\n        \"#main\": {\r\n            extensions: [\"extensions/test\"],\r\n            callback: function(test) {\r\n                // Short Code to execute when Extensions are loaded\r\n            }\r\n        }\r\n    });\r\n    loader.load();\r\n});\r\n```  \r\n\r\nIn this case, the scriptfile `assets/scripts/app/extensions/test.js` will be loaded, if an element with the id \"main\" exists.\r\n\r\nHere we have some cool additional features.\r\nYou can not only assign an object like above to one css-selector. Assigning an array of objects is also totally fine.\r\nUsing an array of objects is extremly useful. The ExtensionLoader will only check the selector once and than load all extensions with the configured callbacks (which are optional by the way).\r\n\r\nYou could theoretically use every kind of selector, but complex ones will lead to poor performance when loading a lot of extensions.\r\n\r\nOn top of that, the ExtensionLoader supports instances. Means, you can load even more extensions from your already loaded extensions. The ExtensionLoader will not re-iterate over the config added in the `config.js`-file.\r\n\r\n#### Different kinds of Configurations\r\n```javascript\r\nloader.addConfig({\r\n    \"#main\": [{\r\n        extensions: [\"extensions/test\"],\r\n        callback: function(test) {\r\n            // Short Code to execute when Extensions are loaded\r\n        }\r\n    }, {\r\n        extensions: [\"extensions/otherExtension\"],\r\n        callback: function(otherExtension) {\r\n            // Short Code to execute when Extensions are loaded\r\n        }\r\n    }]\r\n});\r\n```\r\n\r\nYou think, that's unreadable?  \r\nI've got another solution, which does exactly the same.\r\n\r\n```javascript\r\nloader.addConfig({\r\n    \"#main\": {\r\n        extensions: [\"extensions/test\"],\r\n        callback: function(test) {\r\n            // Short Code to execute when Extensions are loaded\r\n        }\r\n    }\r\n});\r\nloader.addConfig({\r\n    \"#main\": {\r\n        extensions: [\"extensions/otherExtension\"],\r\n        callback: function(otherExtension) {\r\n            // Short Code to execute when Extensions are loaded\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n### extensions/test.js\r\n```javascript\r\ndefine([\"jquery\", \"extensions/lib/Module\"], function(jQuery, Module) {\r\n    var $j = jQuery.noConflict();\r\n\r\n    $j(document).ready(function() {\r\n        var Demo = new Module();\r\n        Demo.doStuff();\r\n    });\r\n});\r\n```  \r\nThis file stores the code that depends on \"#main\".\r\nIn the first line, we define our dependencies for this file.\r\nIn this case, it's jquery and extensions/lib/Module.\r\nThanks to RequireJS, Those files are loaded before executing the rest of this file.\r\n\r\n### Loading Extensions late\r\nSo, we have our application set up and properly running.\r\nSomeone now wants us, to load lots of code exactly 2 minutes after the page loaded.\r\nWe can do that, too.\r\n\r\nWe are building a new extension and import our ExtensionLoader.\r\n```javascript\r\ndefine([\"ExtensionLoader\"], function(ExtensionLoader) {\r\n    var loader = ExtensionLoader();\r\n});\r\n```\r\n\r\nIn here, we configure the extensions, which should be loaded.\r\n\r\n```javascript\r\ndefine([\"ExtensionLoader\"], function(ExtensionLoader) {\r\n    var loader = ExtensionLoader();\r\n\r\n    loader.addConfig({\r\n        \"#demo\": {\r\n            extensions: [\"extensions/anotherExtension\"]\r\n        }\r\n    });\r\n});\r\n```\r\n\r\nAs you may notice, I didn't add the `load`-call.\r\nWe will fire the load 2 minutes after loading the page.\r\nWe just add a setTimeout like this.\r\n```javascript\r\ndefine([\"ExtensionLoader\"], function(ExtensionLoader) {\r\n    var loader = ExtensionLoader();\r\n\r\n    loader.addConfig({\r\n        \"#demo\": {\r\n            extensions: [\"extensions/anotherExtension\"]\r\n        }\r\n    });\r\n\r\n    setTimeout(function() {\r\n        loader.load();\r\n    }, 60000);\r\n});\r\n```\r\n2 minutes after this file is executed, the additional extensions will be loading.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}